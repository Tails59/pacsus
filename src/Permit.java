import java.util.Hashtable;

/* Generated by Together */

/**
 * Abstract superclass of all permit types. Note that since this class is abstract, all "instances"
 * of it are actually instances of its concrete subclasses.
 * The vehicles permitted entry by this permit are recorded here in the permittedVehicles attribute.
 * Further information could be recorded here, such as contact details for the permit holder (and for
 * the hosts in Regular and Day visitor subclasses), but in this design these details are not required.
 * Note that no permit holder may have more than one permit at any time, so no two instances of Permit
 * (through its concrete sub-classes) may have the same permit holder name. There is no direct notation
 * for this. Instead the Permit list object collecting the Permit must enforce it by checking new
 * additions (a hash table will help with this).
 *
 * For subclasses with dates:
 * No permits are issued to span from one year into the next; instead re-issue occurs "automatically" at
 * the start of the year (see the Timer use case diagram - follow hyperlink) - all permits are simply
 * carried over to the new year (except Day visitor and Regular visitor permits that expire on the last
 * day of the year). Permits which have a limited period of validity (Day visitor and Regular visitor
 * permits) are automatically cancelled from PACSUS at the start of the day following their last valid day.
 */
@SuppressWarnings("unused")
abstract public class Permit {
	public static final int MAX_WARNINGS = 3;
	
	/**
	 * Temporary unique ID field, switch this to use a permanent file storage in the actual app
	 */
	private static int uniqueId = 0;
	private final int UNIQUE_ID;
	
    /**
     * The name of the permit holder
     */
	protected String permitHolder;

    /**
     * Counts the number of days on which the campus was entered while the access barriers were in operation.
     * Counting starts when the permit is issued, and afresh at the start of each year.
     */
	protected int noOfEntries = 0;

    /** kay
     * Counts the number of warnings issued to vehicles registered on this permit.
     */
	protected int warnings = 0;

    /**
     * False if the permit has not been suspended, and true if it has (on the third warning).
     */
	protected boolean suspended = false;

    /**
     * Set to false at the start of each day. Remains false until first entry of a vehicle on this permit,
     * when it is set true, and the vehicle is noted in vehicleUsed. Used for checking that subsequent
     * entries in the day are the same vehicle (since exits are not monitored).
     */
	private boolean enteredToday = false;
	
	private Date issueDate;

    /**
     * Once a vehicle has entered on this permit on any day, this attribute records the vehicle that
     * entered, so that any subsequent entries associated with this permit can be verified as the same
     * vehicle (or at least with the same registration number!).
     * The attribute will be null until a vehicle has entered.
     * @clientCardinality 1
     * @directed true
     * @label Allowed today
     * @supplierCardinality 0..1
     */
	private Vehicle_info vehicleUsedToday;

    /**
     * This holds references to all the Vehicle_info instances for the vehicles registered to this permit.
     * Note that any vehicle can be registered to only one permit, but many vehicles may be registered to
     * the same permit.
     * This attribute must be implemented by a collection data structure (such as array, hash table,...).
     * @clientCardinality 1
     * @directed true
     * @label Controls access of
     * @supplierCardinality 0..*
     */
    private Vehicle_list permittedVehicles;
    
    protected Permit(String permitHolder, Vehicle_info firstVehicle, Date issueDate) {
    	this.UNIQUE_ID = uniqueId + 1;
    	uniqueId++;
    	
    	this.permitHolder = permitHolder;
    	this.issueDate = issueDate;
    	
    	try {
			Main.getVehicleList().addNew(firstVehicle, this);
		} catch (Exception e) {
			e.printStackTrace();
		}
    	Main.getPermitList().addPermit(this);
    }
    
    public void addVehicle(Vehicle_info veh) throws Exception {
    	Main.getVehicleList().addNew(veh, this);
    }
    
    public void removeVehicle(Vehicle_info veh) {
    	Main.getVehicleList().remove(veh);
    }
    
    public void addWarning() {
    	this.warnings += 1;
    	
    	if(this.warnings >= MAX_WARNINGS) {
    		this.suspend();
    	}
    }
    
    public void removeWarnings(int amount) {
    	this.warnings -= amount;
    	
    	if(this.suspended && this.warnings <3) {
    		unsuspend();
    	}
    }
    
    private void unsuspend() {
    	this.suspended = false;
    }
    
    private void suspend() {
    	this.suspended = true;
    }
    
    public int getUniqueID() {
    	return this.UNIQUE_ID;
    }
    
    void cancelPermit() {
    	
    }
    
    public Date getIssueDate() {
    	return this.issueDate;
    }
    
    public String getPermitHolder() {
    	return this.permitHolder;
    }
    
    public void setTodaysVehicle(Vehicle_info todaysVehicle) throws Exception {
    	this.vehicleUsedToday = todaysVehicle;
    	this.addVehicle(todaysVehicle);
    }
    
    /**
     * Check if a car is allowed to pass a barrier,
     * i.e. if their permit is not suspended and their issue date is on or before today
     * @return canPass [boolean] If the vehicle is permitted through the barrier
     */
    public boolean canPassBarrier() {
    	return (! this.suspended) && (Main.getSystemStatus().getToday().getDayNumber() >= issueDate.getDayNumber());
    }
}
