import java.util.Hashtable;

/* Generated by Together */

/**
 * Abstract superclass of all permit types. Note that since this class is
 * abstract, all "instances" of it are actually instances of its concrete
 * subclasses. The vehicles permitted entry by this permit are recorded here in
 * the permittedVehicles attribute. Further information could be recorded here,
 * such as contact details for the permit holder (and for the hosts in Regular
 * and Day visitor subclasses), but in this design these details are not
 * required. Note that no permit holder may have more than one permit at any
 * time, so no two instances of Permit (through its concrete sub-classes) may
 * have the same permit holder name. There is no direct notation for this.
 * Instead the Permit list object collecting the Permit must enforce it by
 * checking new additions (a hash table will help with this).
 *
 * For subclasses with dates: No permits are issued to span from one year into
 * the next; instead re-issue occurs "automatically" at the start of the year
 * (see the Timer use case diagram - follow hyperlink) - all permits are simply
 * carried over to the new year (except Day visitor and Regular visitor permits
 * that expire on the last day of the year). Permits which have a limited period
 * of validity (Day visitor and Regular visitor permits) are automatically
 * cancelled from PACSUS at the start of the day following their last valid day.
 */
@SuppressWarnings("unused")
public class Permit {
	public static final int MAX_WARNINGS = 3;

	/**
	 * Temporary unique ID field, switch this to use a permanent file storage in the
	 * actual app
	 */
	private static int uniqueId = 0;
	private final int UNIQUE_ID;

	/**
	 * The name of the permit holder
	 */
	protected String permitHolder;

	/**
	 * Counts the number of days on which the campus was entered while the access
	 * barriers were in operation. Counting starts when the permit is issued, and
	 * afresh at the start of each year.
	 */
	protected int noOfEntries = 0;

	/**
	 * Counts the number of warnings issued to vehicles registered on this permit.
	 */
	protected int warnings = 0;

	/**
	 * False if the permit has not been suspended, and true if it has (on the third
	 * warning).
	 */
	protected boolean suspended = false;

	/**
	 * Set to false at the start of each day. Remains false until first entry of a
	 * vehicle on this permit, when it is set true, and the vehicle is noted in
	 * vehicleUsed. Used for checking that subsequent entries in the day are the
	 * same vehicle (since exits are not monitored).
	 */
	private boolean enteredToday = false;

	private Date issueDate;

	/**
	 * Once a vehicle has entered on this permit on any day, this attribute records
	 * the vehicle that entered, so that any subsequent entries associated with this
	 * permit can be verified as the same vehicle (or at least with the same
	 * registration number!). The attribute will be null until a vehicle has
	 * entered.
	 * 
	 * @clientCardinality 1
	 * @directed true
	 * @label Allowed today
	 * @supplierCardinality 0..1
	 */
	private Vehicle_info vehicleUsedToday;

	/**
	 * This holds references to all the Vehicle_info instances for the vehicles
	 * registered to this permit. Note that any vehicle can be registered to only
	 * one permit, but many vehicles may be registered to the same permit. This
	 * attribute must be implemented by a collection data structure (such as array,
	 * hash table,...).
	 * 
	 * @clientCardinality 1
	 * @directed true
	 * @label Controls access of
	 * @supplierCardinality 0..*
	 */
	private Vehicle_list permittedVehicles;

	/**
	 * Set the permit holder
	 * 
	 * @param permitHolder [String] Name of the person that owns this permit
	 */
	public void setPermitHolder(String permitHolder) {
		this.permitHolder = permitHolder;
	}

	/**
	 * Set the permit's issue date
	 * 
	 * @param issueDate [Date] date the permit was issued
	 */
	public void setIssueDate(Date issueDate) {
		this.issueDate = issueDate;
	}

	/**
	 * Create a new permit - called by concrete subclasses of the different permit
	 * types
	 * 
	 * @param permitHolder [String] name of the person that owns this permit
	 * @param firstVehicle [Vehicle_info] First vehicle associated with this permit,
	 *                     guarantees at least 1 vehicle is assigned to permit
	 * @param issueDate    [Date] date the perimt was issued, usually the current
	 *                     date
	 */
	protected Permit(String permitHolder, Vehicle_info firstVehicle, Date issueDate) {
		this.UNIQUE_ID = uniqueId + 1;
		uniqueId++;

		this.permitHolder = permitHolder;
		this.issueDate = issueDate;

		permittedVehicles = Main.getVehicleList();

		try {
			permittedVehicles.addNew(firstVehicle, this);
		} catch (Exception e) {
			Main.adminOffice1.displayAlert("Issue with adding of new vehicle", 'e');
			e.printStackTrace();
		}

		firstVehicle.setPermit(this);
		// Main.getPermitList().addPermit(this);
	}

	/**
	 * Add a vehicle to this permit
	 * 
	 * @param veh [Vehicle_info] Vehicle to be added
	 * @throws Exception if the vehicle cannnot be added
	 */
	public void addVehicle(Vehicle_info veh) throws Exception {
		permittedVehicles.addNew(veh, this);
	}

	/**
	 * Remove a vehicle from this permit
	 * 
	 * @param veh [Vehicle_info] Vehicle to be removed
	 */
	public void removeVehicle(Vehicle_info veh) {
		permittedVehicles.remove(veh);
	}

	/**
	 * Add a warning to this permit for any reason
	 * 
	 * If this is the third warning, the permit will be automatically suspended
	 */
	public void addWarning() {
		if (warnings == MAX_WARNINGS - 1) {
			suspend();
		}

		this.warnings += 1;
	}

	/**
	 * Whether this permit is suspended
	 * 
	 * @return suspended [boolean] True if the permit is suspended and cannot access
	 *         the barriers
	 */
	public boolean isSuspended() {
		return suspended;
	}

	/**
	 * Get the number of warnings this permit has
	 * 
	 * @return warnings [int] the number of warnings
	 */
	public int getWarnings() {
		return this.warnings;
	}

	/**
	 * Remove one or more warnings from this permit
	 * 
	 * @param amount [int] number of warnings to remove
	 */
	public void removeWarnings(int amount) {
		this.warnings -= amount;

		if (this.suspended && this.warnings < 3) {
			unsuspend();
		}
	}

	/**
	 * Unsuspend this permit
	 */
	void unsuspend() {
		this.suspended = false;
	}

	/**
	 * Suspend this permit
	 */
	private void suspend() {
		this.suspended = true;
	}

	/**
	 * Add an entry to this permit
	 */
	public void addEntry() {
		this.noOfEntries += 1;
		entered();
	}

	/**
	 * Reset the number of entries, done at the start of each year
	 */
	public void resetEntry() {
		this.enteredToday = false;
	}

	/**
	 * Set permits state as entered today as true
	 */
	public void setEntry() {
		this.enteredToday = true;
	}

	/**
	 * Reset the number of times this vehicle has passed the barriers
	 */
	public void resetEntries() {
		this.noOfEntries = 0;
	}

	/**
	 * Get the number of entries
	 * 
	 * @return
	 */
	public int getEntries() {
		return this.noOfEntries;
	}

	/**
	 * Called when this vehicle enters the barriers, records that they have entered
	 * today
	 * 
	 * @return
	 */
	public boolean entered() {
		return this.enteredToday;
	}

	/**
	 * Get this permits unique ID, used for searching
	 * 
	 * @return
	 */
	public int getUniqueID() {
		return this.UNIQUE_ID;
	}

	/**
	 * The date this permit was issued
	 * 
	 * @return
	 */
	public Date getIssueDate() {
		return this.issueDate;
	}

	/**
	 * The name of the person who owns this permit
	 * 
	 * @return
	 */
	public String getPermitHolder() {
		return this.permitHolder;
	}

	/**
	 * Set the vehicle that the permit holder used today
	 * 
	 * @param todaysVehicle
	 * @throws Exception
	 */
	public void setTodaysVehicle(Vehicle_info todaysVehicle) throws Exception {
		this.vehicleUsedToday = todaysVehicle;
		this.addVehicle(todaysVehicle);
	}

	/**
	 * Check if a car is allowed to pass a barrier, i.e. if their permit is not
	 * suspended and their issue date is on or before today
	 * 
	 * @return canPass [boolean] If the vehicle is permitted through the barrier
	 */
	public boolean canPassBarrier() {
		return (!this.suspended) && (Main.getSystemStatus().getToday().getDayNumber() >= issueDate.getDayNumber());
	}
}
